---
ID: WEB001
Date: 07/07/2025
Tags: #csrf #webapp #tokens
Category: Web Application
---

# WEB001 – CSRF Tokens

## 🧠 What I Learned

**Cross-Site Request Forgery (CSRF)** is a type of attack where a malicious website tricks a user’s browser into making unwanted requests to a different site where the user is authenticated.

To mitigate CSRF, **CSRF tokens** are implemented. These are unique, unpredictable values generated by the server and embedded in forms or headers. The server checks for this token in every state-changing request (POST, PUT, DELETE), ensuring the request came from a valid source.

If the token is missing or invalid, the request is rejected.

---

## 🔐 Why CSRF Tokens Work

- **Tokens are bound to user sessions**  
- **Attackers can't read tokens** due to Same-Origin Policy  
- **Each request is validated** for both session and token

---

## 🛠️ Practical Notes

- CSRF protection often comes in the form of:
  - Hidden form fields:  
    `<input type="hidden" name="csrf_token" value="xyz">`
  - Custom headers:  
    `X-CSRF-Token: abc123`
- Tools like Burp Suite can detect missing/weak CSRF protections
- SameSite cookies also reduce CSRF risk (especially `Strict` or `Lax` mode)

---

## 💥 Common Mistakes

- Tokens not checked on the server (present but unused)
- Tokens reused across sessions
- State-changing actions via GET requests (bad practice)

---

## 🔗 Resources

- [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
- [PortSwigger: CSRF](https://portswigger.net/web-security/csrf)

---

## ✅ Key Takeaway

> Without CSRF tokens, a malicious page can use your browser’s cookies to submit unauthorized actions on your behalf.  
> **Always verify origin and token for state-changing operations.**
